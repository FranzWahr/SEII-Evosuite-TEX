\documentclass[pdftex,english,oribibl]{llncs}

%% Spracheinstellungen laden
\usepackage[english]{babel}

%% Schriftart in der Ausgabe/Eingabe
\usepackage[T1]{fontenc}
\usepackage{textcomp}
\usepackage[latin1]{inputenc}

%% Zitate
\usepackage[numbers]{natbib}
\bibliographystyle{abbrvnat}
%\bibliographystyle{dinat}
%\bibliographystyle{plainnat}
%\bibliographystyle{splncs}
%% Similar to option "sectionbib" but \refname instead of \bibname
\makeatletter
\renewcommand\bibsection{\section*{\refname\@mkboth{\MakeUppercase{\refname}}{\MakeUppercase{\refname}}}}
\makeatother

%% Index
%\usepackage{makeidx}
%\makeindex

%% PDF Einstellungen
% muss nach natbib geladen werden!
\usepackage{nameref}
\usepackage{varioref}
\usepackage[pdfusetitle,pdftex,colorlinks]{hyperref}
\hypersetup{pdfborder={0 0 0}}
\hypersetup{bookmarksdepth=3}
\hypersetup{bookmarksopen=true}
\hypersetup{bookmarksopenlevel=1}
\hypersetup{bookmarksnumbered=true}
\usepackage{color}
\hypersetup{colorlinks=false}
\usepackage{titling}

%\usepackage[section]{tocbibind}

\makeatletter
\gdef\@keywords{}
\def\keywords#1{\gdef\@keywords{#1}}
\gdef\@subtitle{}
\def\subtitle#1{\gdef\@subtitle{#1}}

%% modified from llncs
\renewenvironment{abstract}{%
  \list{}{\advance\topsep by0.35cm\relax\small%
          \leftmargin=1cm%
          \labelwidth=\z@%
          \listparindent=\z@%
          \itemindent\listparindent%
          \rightmargin\leftmargin}%
          \item[\hskip\labelsep\bfseries\abstractname]}{%
  \if!\@keywords!\else{\item[~]\item[\hskip\labelsep\bfseries\keywordname]\@keywords}\fi%
  \endlist}

\AtBeginDocument{%
  \if!\@subtitle!\else\hypersetup{pdfsubject={\@subtitle}}\fi
  \if!\@keywords!\else\hypersetup{pdfkeywords={\@keywords}}\fi
}
\makeatother

% llncs hyperref fix
\makeatletter
\providecommand*{\toclevel@author}{0}
\providecommand*{\toclevel@title}{0}
\makeatother

%% Grafiken
\usepackage[pdftex]{graphicx}
\DeclareGraphicsExtensions{.pdf,.jpg,.png}
\usepackage{subfigure}

%% Mathe
\usepackage{amsmath}
\usepackage{amssymb}

%% Listings
\usepackage{listings}
\lstset{escapechar=\%, frame=tb, basicstyle=\footnotesize}

%% Sonstiges
\newcommand{\TODO}[1]{\par\textcolor{red}{#1}\marginpar{\textcolor{red}{TODO}}}
\newcommand{\TODOX}[1]{\textcolor{red}{#1}\marginpar{\textcolor{red}{TODO}}}
\pagestyle{plain}

% Keine "Schusterjungen"
\clubpenalty = 10000
% Keine "Hurenkinder"
\widowpenalty = 10000 \displaywidowpenalty = 10000

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%% BEGIN DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\pretitle{%
  \begin{center}\LARGE
  \noindent\includegraphics[height=2.5cm]{figures/logo-se}\hfill{}\includegraphics[height=2.5cm]{figures/logo-uni}\\\vspace{0.5cm}
}
\title{Evosuite Report-Paper}
% \subtitle{My (optional) Subtitle}
\author{Hoang, Lam\\ Peverali, Francois \\ Allogie, Mohamad Jamal}
\institute{Humboldt University of Berlin\\Department of Computer Science\\12489 Berlin, Germany}
\posttitle{\end{center}}


\begin{document}

\maketitle

\begin{abstract}
  Software testing is a very tedious and expensive activity, therefore automatically generating test cases for finding defects in program code can help to efficiently build qualitative products. \textsc{EvoSuite} is a tool that both helps generating \textit{test cases} and \textit{oracles}, that assert the correctness of a programs behaviour at runtime, but also allows to identify a test suites coverage. Thereby it is using a novel approach that aims at optimizing \textit{whole test suites} by approaching a coverage criterion using a mutation-based assertion generation. The following paper validates  the named approach by comparing the test suite generated by \textsc{EvoSuite} to a single goal oriented test generation approach.
  
\end{abstract}

\section{Introduction}

Software products are inherently error prone and therefore software developers need efficient methods and techniques to test their programs against possible faults. Testing of software is a lengthy procedure and therefore related to high costs because it does not add any value to the final product. Still, it is a necessary activity, since a high code coverage by test cases reduces bugs and thereby faulty program behavior. Therefore helping developers with the activity of software verification by automatically generating test cases is a welcome approach to this issue.
Given a source code of a program, there are different approaches to automated test case generation to help the developer finding bugs in the software. There are already many tools which automatically generate test cases, that implement different approaches. They all share three fundamental parameters, which are given by the coverage, the redundancy (of test cases or statements within test-cases) and spent time for the test case generation, that are related to each other. We can differentiate between three basic approaches for automated white-box testing: the varying aims of test-case generation techniques consist either in approximating the test coverage of a specified line (though a fitness function), optimizing a single goal, which could be a determined class, by converging towards a coverage criterion for this specific program context or -- last, not least -- in whole test suite optimization through a coverage criterion. 
The latter is adopted by \textsc{EvoSuite} which is discussed by Fraser and Arcuru \citet{fraser2011evosuite}.
As an whole test suite generation tool \textsc{EvoSuite} generates both tests and assertions for Java Classes. More exactly it restricts the oracle problem with a mutation based approach, which is a key problem in automated software testing and basically consists in minimizing possible assertions for a given set of tests. This is a crucial issue since automated test generation often overfulfils its aims by creating tests which are in one and the same equivalence class thereby confronting the testing developer with a high number of inefficient test-cases and the difficulty to choose and discard the ones that are not needed or redundant for testing a certain program behavior. Moreover, \textsc{EvoSuite} offers the choice between several coverage criteria for the test suite's optimization, i.e. line, branch output and mutation testing. In so doing it also provides different metrics to analyze a given test suite, which is another feature it provides. \textsc{EvoSuite} is provided as a command line tool but offers as well Integration for multiple IDEs and platforms like Eclipse, IntelliJ and Maven.
This paper aims at validating the \textsc{EvoSuite} approach by providing further empirical data on the effectiveness of test suite optimization in comparison to both a traditional approach and the so called LIPS method for automated test case generation.

The following subsection~\ref{subsec:anotherContribution} presents our contributions to this field of research.
The Section~\ref{sec:anotherSection} presents background information and discussion distinguishing the strength and weaknesses emerging from a traditional approach of automated test case generation and from the whole test suite generation method. 
The Section~\ref{sec:evaluation} provides information on our experimental setup and the empirical data gathered from it and the section~\ref{sec:discussion} analyses and discusses its results.
  The conclusions follow in Section~\ref{sec:conclusions}.

\subsection{Contribution}\label{subsec:anotherContribution}

Our contributions consist of...(Am Ende der introduction sollt ihr klar (in einer Liste) eure persönlichen contributions darstellen, also prinzipiell den Mehrwert eurer durchgeführten Versuche.)


\section{Background}\label{sec:anotherSection}
Software-testing within software-engineering deals with systematically verifying the functionality of the tested program and thereby assuring its quality. For increasing the efficiency of writing test-cases automated methods that seek to generate test-cases by iterating through a possible search-space are being used. A comprehensive comparison of both a traditional and a novel approach in search-based software testing is offered by Rojas et al. \citep{rojas2017detailed}. A common scenario for software-based software testing consists in generating "a set of test cases maximizing their code coverage or maximizing their fault detection capability" being branch coverage a de facto standard coverage criterion within the reasearch field. Furthermore it states that the traditional approach can be characterized as a single goal approach, i.e. that each coverage goal is approximated individually. Whereas for the novel \textit{whole test suite} approach proposed by Rojas et al. "the problem is changed to a search for a set of tests that covers all coverage goals at the same time", thereby solving two issues of the traditional approach, which are given by the \textit{search budget distribution problem} and the \textit{ordering of the coverage goals}. The former consisting in the fact, that the infeasibility of coverage goals is an undecidable problem, which means that a test generation software could unnecessarily spend ressources on test generation for a coverage goal that could never be reached. The latter consisting in the fact that each goal is tipycally approximated individually and useful information is not shared between the single search processes. 

A detailed description for the traditional approach is provided by McMinn \citep{mcminn2004search} and Wegener \citep{wegener2001evolutionary},  whereas a more detailed description of the whole test suite approach can be found at Fraser and Arcuri \citep{fraser2015achieving}.

\subsection{Problem Description} 


TODO:
....(Erklärt das behandelte Problem und warum dessen Lösung wichtig ist. Gebt dem Leser ausreichend Hintergrundinformationen um eure Arbeit zu verstehen. Stellt die benutzten/behandelten Tools dar und ggf. eure durchgeführten Modifikationen. Gebt ausreichend exemplarisches Material in Form von figures, tables, etc.)

By the way, this was an example for using the \textit{natbib} command \texttt{\textbackslash{}citep\{\}}.

  We will now demonstrate how to use subfigures (see Figure~\ref{fig:subfig}). Figure~\ref{fig:circle} shows a circle. A star is displayed in Figure~\ref{fig:star}.

  \begin{figure}
    \centering
    \subfigure[This is a circle.]{\label{fig:circle}
      \includegraphics[width=0.3\textwidth]{figures/template_circle.pdf}
    }
    \subfigure[This is a star.]{\label{fig:star}
      \includegraphics[width=0.3\textwidth]{figures/template_star.pdf}
    }
    \caption{A circle (a) and a star (b). Note that any caption ends with a full stop character.}
    \label{fig:subfig}
  \end{figure}

\section{Evaluation}\label{sec:evaluation}

  These are my evaluations.
  
  \subsection{Solution and Evaluation Description}
  
  ...(Beschreibt die Lösung des behandelten Problems, bzw. eure durchgeführten Analysen. Gebt zudem auch Informationen zu benutzten Metriken, wie diese zu berechnen sind, und über den Aufbau eurer Experimente.)
  
  
\section{Discussion}\label{sec:discussion}

  ...discussion.
  
    \subsection{Results Discussion} 
    ...(Stellt die eure Ergebnisse vor und erklärt den Ausgang eurer Experimente. Zieht Folgerungen aus den Ergebnissen. Beschreibt die nächsten Schritte, die durchgeführt werden müssten/könnten und anderen "Future Work".)
    
    \subsection{Related Work}
    TODO...Geht kurz auf themenverwandte Arbeiten ein. Was unterscheidet eure Arbeit von anderen Ansätzen, etc.? TODO .
    
    Fraser and Arcuri \cite{fraser2013whole}, \citep{fraser2015achieving} have provided an empirical study on the whole test suite approach proving that it can achieve a higher code coverage than the traditional approach.
    Furthermore Rojas et al. \citep{rojas2017detailed} have analyzed in-depth possible problem sources of the novel approach caused by the fact that a higher code coverage does not necessarily imply that all cases of the traditional approach are covered by the whole test suite approach. They've come to the conclusion that there are in fact specific contexts in which a single goal approach can outperform the whole test suite approach even on code coverage, still being "special cases, rather than general efficiencies of the approach", which -- as they show -- can be improved by adding an "archive", which still needs further research.
    
    Our evaluation of \textsc{EvoSuite} validates the findings of Fraser and Arcuri \cite{fraser2013whole} by using the tool for test suite optimization on another buggy software (...) the results of the code coverage of adopting \textsc{EvoSuite} show to outperform the single goal approach used as comparison... 
   

\section{Conclusions}\label{sec:conclusions}

  These are my conclusions.
  
\bibliography{template}


\end{document}
